# Chapter 10. 테스트 코드와 유지보수

서비스의 빠른 출시 및 업데이트를 위해 CI(Continuous Integration), CD(Continuous Delivery)를 도입하는 곳이 점점 많아지고 있다. 코드를 지속적으로 통합하고 출시하려면 새로
추가된 코드가 올바른 코드인지 확인할 수 있어야 한다.

그래서 **자동화 테스트**는 CI/CD의 필수품으로 여겨진다. TDD를 통해 작성한 테스트가 CI/CD 과정에서 자동으로 실행되어 코드의 오류를 잡아낸다.

## 테스트 코드도 코드다

테스트 코드 역시 코드이므로 유지보수하기 쉽게 작성해야 한다. 테스트를 유지보수하지 않으면 잠재적으로 테스트가 확인하는 범위가 줄어들 수 있고, 이는 테스트가 코드를 완전히 검사하지 못한다는 사실을 의미한다.

끝내 테스트가 실패해도 신경쓰지 않게 되는 최악의 상황까지 이를 수 있다. 테스트 코드를 유지보수하기 쉽게 작성해야만 테스트 대상 역시 테스트 가능한 방식으로 작성할 수 있다.

이 장에서는 TDD 입문자들이 자주 하는 실수와 주의 사항을 살펴볼 것이다.

### 기대하는 값(expect)을 상수로 사용하기

기대하는 값을 상수로 표현하자. 변수 또는 변수의 필드를 사용하면 테스트 코드를 이해하기 위해 코드를 이리저리 탐색해야 한다.

### 하나의 테스트에서 하나의 개념만 검증하기

서로 다른 개념을 하나의 테스트에서 검증하면, 테스트가 실패해도 어디서 실패했는지 알기 어려워진다. 최대한 작은 개념 하나만을 검증하도록 노력하자.

### 내부 구현까지 검증하지는 말기

`Mockito` 등을 사용하여 모의 객체를 선언할 떄 하기 쉬운 실수이다. 내부 구현은 언제든지 바뀔 수 있으므로 테스트에서는 메서드 또는 객체의 실행 결과에만 집중하는 편이 좋다.

불가피하게 구현을 검증해야 하는 경우도 있지만, 되도록이면 코드 라인 하나하나를 파헤치지 않아도 되도록 리팩토링하자.

### `@Before`, `@BeforeEach`는 신중하게 사용하기

`@BeforeEach`로 테스트의 초기 상황을 설정했다는 사실을 까먹을 때가 있다. 이런 상황에서 테스트가 실패한다면 실패의 원인을 찾기 어려워진다.

테스트의 중복을 줄이고 코드를 짧게 할 수 있지만, 단점이 없는 건 아니라고..

### 여러 실행 환경에서 일관되게 동작하기

Windows에서는 성공하는데 Linux에서는 실패한다던가, 다른 디렉토리에서 실행했더니 실패한다던가.. 테스트의 권위를 위협하는 일이 없어야 한다.

아주 가끔 특정 OS에서만 실행해야 하는 테스트도 있는데, 이런 경우에는 `@EnableOnOs`, `@DisableOnOs` 어노테이션을 사용하자.

### 실행 시간이 달라져도 일관되게 동작하기

위의 항목과 이어지는 내용으로, 테스트 코드가 시간에 종속적이면 안 된다. 오늘은 성공했는데 내일 실패하는 테스트 코드는 단순히 글자 더미에 지나지 않는다.

테스트가 시간을 다룬다면, 테스트 코드에서 시간을 명시적으로 제어할 수 있는 방법을 마련해야 한다.

### 랜덤 값을 사용하지 않기

랜덤으로 뽑힌 값에 의해 테스트의 실행 결과가 달라지면 안 된다. 계속 강조하는 내용이지만, 테스트 코드는 항상 동일한 방법으로 동작해야 한다. 무작위 요소가 끼어들면 안 된다.

### 조건부로 검증하지 않기

`assert`를 실행하지 않는 테스트는 존재 의미가 없다. `assert`를 실행하지 않고 그냥 끝나면 개발자 입장에서 테스트가 성공했다고 착각하기 쉽다. 차라리 테스트가 실패하는 상황이 훨씬 낫다.

### 쓸모 없는 테스트는 삭제하기

사용하지 않는 객체나 메서드를 테스트할 필요는 없다. git이 알아서 기억하고 있으니 과감하게 삭제하자.